<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_07) on Fri Dec 21 14:04:08 MST 2012 -->
<title>Phaser (MinesJTK)</title>
<meta name="date" content="2012-12-21">
<link rel="stylesheet" type="text/css" href="../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Phaser (MinesJTK)";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Phaser.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-all.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../jsr166y/LinkedTransferQueue.html" title="class in jsr166y"><span class="strong">Prev Class</span></a></li>
<li><a href="../jsr166y/RecursiveAction.html" title="class in jsr166y"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../index.html?jsr166y/Phaser.html" target="_top">Frames</a></li>
<li><a href="Phaser.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">jsr166y</div>
<h2 title="Class Phaser" class="title">Class Phaser</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>jsr166y.Phaser</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="strong">Phaser</span>
extends java.lang.Object</pre>
<div class="block">A reusable synchronization barrier, similar in functionality to
 <code>CyclicBarrier</code> and
 <code>CountDownLatch</code>
 but supporting more flexible usage.

 <p> <b>Registration.</b> Unlike the case for other barriers, the
 number of parties <em>registered</em> to synchronize on a phaser
 may vary over time.  Tasks may be registered at any time (using
 methods <a href="../jsr166y/Phaser.html#register()"><code>register()</code></a>, <a href="../jsr166y/Phaser.html#bulkRegister(int)"><code>bulkRegister(int)</code></a>, or forms of
 constructors establishing initial numbers of parties), and
 optionally deregistered upon any arrival (using <a href="../jsr166y/Phaser.html#arriveAndDeregister()"><code>arriveAndDeregister()</code></a>).  As is the case with most basic
 synchronization constructs, registration and deregistration affect
 only internal counts; they do not establish any further internal
 bookkeeping, so tasks cannot query whether they are registered.
 (However, you can introduce such bookkeeping by subclassing this
 class.)

 <p> <b>Synchronization.</b> Like a <code>CyclicBarrier</code>, a <code>Phaser</code> may be repeatedly awaited.  Method <a href="../jsr166y/Phaser.html#arriveAndAwaitAdvance()"><code>arriveAndAwaitAdvance()</code></a> has effect analogous to <code>CyclicBarrier.await</code>. Each
 generation of a <code>Phaser</code> has an associated phase number. The
 phase number starts at zero, and advances when all parties arrive
 at the barrier, wrapping around to zero after reaching <code>Integer.MAX_VALUE</code>. The use of phase numbers enables independent
 control of actions upon arrival at a barrier and upon awaiting
 others, via two kinds of methods that may be invoked by any
 registered party:

 <ul>

   <li> <b>Arrival.</b> Methods <a href="../jsr166y/Phaser.html#arrive()"><code>arrive()</code></a> and
       <a href="../jsr166y/Phaser.html#arriveAndDeregister()"><code>arriveAndDeregister()</code></a> record arrival at a
       barrier. These methods do not block, but return an associated
       <em>arrival phase number</em>; that is, the phase number of
       the barrier to which the arrival applied. When the final
       party for a given phase arrives, an optional barrier action
       is performed and the phase advances.  Barrier actions,
       performed by the party triggering a phase advance, are
       arranged by overriding method <a href="../jsr166y/Phaser.html#onAdvance(int, int)"><code>onAdvance(int, int)</code></a>,
       which also controls termination. Overriding this method is
       similar to, but more flexible than, providing a barrier
       action to a <code>CyclicBarrier</code>.

   <li> <b>Waiting.</b> Method <a href="../jsr166y/Phaser.html#awaitAdvance(int)"><code>awaitAdvance(int)</code></a> requires an
       argument indicating an arrival phase number, and returns when
       the barrier advances to (or is already at) a different phase.
       Unlike similar constructions using <code>CyclicBarrier</code>,
       method <code>awaitAdvance</code> continues to wait even if the
       waiting thread is interrupted. Interruptible and timeout
       versions are also available, but exceptions encountered while
       tasks wait interruptibly or with timeout do not change the
       state of the barrier. If necessary, you can perform any
       associated recovery within handlers of those exceptions,
       often after invoking <code>forceTermination</code>.  Phasers may
       also be used by tasks executing in a <a href="../jsr166y/ForkJoinPool.html" title="class in jsr166y"><code>ForkJoinPool</code></a>,
       which will ensure sufficient parallelism to execute tasks
       when others are blocked waiting for a phase to advance.

 </ul>

 <p> <b>Termination.</b> A <code>Phaser</code> may enter a
 <em>termination</em> state in which all synchronization methods
 immediately return without updating phaser state or waiting for
 advance, and indicating (via a negative phase value) that execution
 is complete.  Termination is triggered when an invocation of <code>onAdvance</code> returns <code>true</code>.  As illustrated below, when
 phasers control actions with a fixed number of iterations, it is
 often convenient to override this method to cause termination when
 the current phase number reaches a threshold. Method <a href="../jsr166y/Phaser.html#forceTermination()"><code>forceTermination()</code></a> is also available to abruptly release waiting
 threads and allow them to terminate.

 <p> <b>Tiering.</b> Phasers may be <em>tiered</em> (i.e., arranged
 in tree structures) to reduce contention. Phasers with large
 numbers of parties that would otherwise experience heavy
 synchronization contention costs may instead be set up so that
 groups of sub-phasers share a common parent.  This may greatly
 increase throughput even though it incurs greater per-operation
 overhead.

 <p><b>Monitoring.</b> While synchronization methods may be invoked
 only by registered parties, the current state of a phaser may be
 monitored by any caller.  At any given moment there are <a href="../jsr166y/Phaser.html#getRegisteredParties()"><code>getRegisteredParties()</code></a> parties in total, of which <a href="../jsr166y/Phaser.html#getArrivedParties()"><code>getArrivedParties()</code></a> have arrived at the current phase (<a href="../jsr166y/Phaser.html#getPhase()"><code>getPhase()</code></a>).  When the remaining (<a href="../jsr166y/Phaser.html#getUnarrivedParties()"><code>getUnarrivedParties()</code></a>)
 parties arrive, the phase advances.  The values returned by these
 methods may reflect transient states and so are not in general
 useful for synchronization control.  Method <a href="../jsr166y/Phaser.html#toString()"><code>toString()</code></a>
 returns snapshots of these state queries in a form convenient for
 informal monitoring.

 <p><b>Sample usages:</b>

 <p>A <code>Phaser</code> may be used instead of a <code>CountDownLatch</code>
 to control a one-shot action serving a variable number of parties.
 The typical idiom is for the method setting this up to first
 register, then start the actions, then deregister, as in:

  <pre> <code>void runTasks(List&lt;Runnable&gt; tasks) {
   final Phaser phaser = new Phaser(1); // "1" to register self
   // create and start threads
   for (Runnable task : tasks) {
     phaser.register();
     new Thread() {
       public void run() {
         phaser.arriveAndAwaitAdvance(); // await all creation
         task.run();
       }
     }.start();
   }

   // allow threads to start and deregister self
   phaser.arriveAndDeregister();
 }</code></pre>

 <p>One way to cause a set of threads to repeatedly perform actions
 for a given number of iterations is to override <code>onAdvance</code>:

  <pre> <code>void startTasks(List&lt;Runnable&gt; tasks, final int iterations) {
   final Phaser phaser = new Phaser() {
     protected boolean onAdvance(int phase, int registeredParties) {
       return phase &gt;= iterations || registeredParties == 0;
     }
   };
   phaser.register();
   for (final Runnable task : tasks) {
     phaser.register();
     new Thread() {
       public void run() {
         do {
           task.run();
           phaser.arriveAndAwaitAdvance();
         } while (!phaser.isTerminated());
       }
     }.start();
   }
   phaser.arriveAndDeregister(); // deregister self, don't wait
 }</code></pre>

 If the main task must later await termination, it
 may re-register and then execute a similar loop:
  <pre> <code>// ...
   phaser.register();
   while (!phaser.isTerminated())
     phaser.arriveAndAwaitAdvance();</code></pre>

 <p>Related constructions may be used to await particular phase numbers
 in contexts where you are sure that the phase will never wrap around
 <code>Integer.MAX_VALUE</code>. For example:

  <pre> <code>void awaitPhase(Phaser phaser, int phase) {
   int p = phaser.register(); // assumes caller not already registered
   while (p &lt; phase) {
     if (phaser.isTerminated())
       // ... deal with unexpected termination
     else
       p = phaser.arriveAndAwaitAdvance();
   }
   phaser.arriveAndDeregister();
 }</code></pre>


 <p>To create a set of tasks using a tree of phasers,
 you could use code of the following form, assuming a
 Task class with a constructor accepting a phaser that
 it registers with upon construction:

  <pre> <code>void build(Task[] actions, int lo, int hi, Phaser ph) {
   if (hi - lo &gt; TASKS_PER_PHASER) {
     for (int i = lo; i &lt; hi; i += TASKS_PER_PHASER) {
       int j = Math.min(i + TASKS_PER_PHASER, hi);
       build(actions, i, j, new Phaser(ph));
     }
   } else {
     for (int i = lo; i &lt; hi; ++i)
       actions[i] = new Task(ph);
       // assumes new Task(ph) performs ph.register()
   }
 }
 // .. initially called, for n tasks via
 build(new Task[n], 0, n, new Phaser());</code></pre>

 The best value of <code>TASKS_PER_PHASER</code> depends mainly on
 expected barrier synchronization rates. A value as low as four may
 be appropriate for extremely small per-barrier task bodies (thus
 high rates), or up to hundreds for extremely large ones.

 <p><b>Implementation notes</b>: This implementation restricts the
 maximum number of parties to 65535. Attempts to register additional
 parties result in <code>IllegalStateException</code>. However, you can and
 should create tiered phasers to accommodate arbitrarily large sets
 of participants.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>1.7</dd>
<dt><span class="strong">Author:</span></dt>
  <dd>Doug Lea</dd></dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../jsr166y/Phaser.html#Phaser()">Phaser</a></strong>()</code>
<div class="block">Creates a new phaser without any initially registered parties,
 initial phase number 0, and no parent.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><strong><a href="../jsr166y/Phaser.html#Phaser(int)">Phaser</a></strong>(int&nbsp;parties)</code>
<div class="block">Creates a new phaser with the given number of registered
 unarrived parties, initial phase number 0, and no parent.</div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../jsr166y/Phaser.html#Phaser(jsr166y.Phaser)">Phaser</a></strong>(<a href="../jsr166y/Phaser.html" title="class in jsr166y">Phaser</a>&nbsp;parent)</code>
<div class="block">Creates a new phaser with the given parent, without any
 initially registered parties.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><strong><a href="../jsr166y/Phaser.html#Phaser(jsr166y.Phaser, int)">Phaser</a></strong>(<a href="../jsr166y/Phaser.html" title="class in jsr166y">Phaser</a>&nbsp;parent,
      int&nbsp;parties)</code>
<div class="block">Creates a new phaser with the given parent and number of
 registered unarrived parties.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../jsr166y/Phaser.html#arrive()">arrive</a></strong>()</code>
<div class="block">Arrives at the barrier, but does not wait for others.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../jsr166y/Phaser.html#arriveAndAwaitAdvance()">arriveAndAwaitAdvance</a></strong>()</code>
<div class="block">Arrives at the barrier and awaits others.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../jsr166y/Phaser.html#arriveAndDeregister()">arriveAndDeregister</a></strong>()</code>
<div class="block">Arrives at the barrier and deregisters from it without waiting
 for others.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../jsr166y/Phaser.html#awaitAdvance(int)">awaitAdvance</a></strong>(int&nbsp;phase)</code>
<div class="block">Awaits the phase of the barrier to advance from the given phase
 value, returning immediately if the current phase of the
 barrier is not equal to the given phase value or this barrier
 is terminated.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../jsr166y/Phaser.html#awaitAdvanceInterruptibly(int)">awaitAdvanceInterruptibly</a></strong>(int&nbsp;phase)</code>
<div class="block">Awaits the phase of the barrier to advance from the given phase
 value, throwing <code>InterruptedException</code> if interrupted
 while waiting, or returning immediately if the current phase of
 the barrier is not equal to the given phase value or this
 barrier is terminated.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../jsr166y/Phaser.html#awaitAdvanceInterruptibly(int, long, java.util.concurrent.TimeUnit)">awaitAdvanceInterruptibly</a></strong>(int&nbsp;phase,
                         long&nbsp;timeout,
                         java.util.concurrent.TimeUnit&nbsp;unit)</code>
<div class="block">Awaits the phase of the barrier to advance from the given phase
 value or the given timeout to elapse, throwing <code>InterruptedException</code> if interrupted while waiting, or
 returning immediately if the current phase of the barrier is
 not equal to the given phase value or this barrier is
 terminated.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../jsr166y/Phaser.html#bulkRegister(int)">bulkRegister</a></strong>(int&nbsp;parties)</code>
<div class="block">Adds the given number of new unarrived parties to this phaser.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../jsr166y/Phaser.html#forceTermination()">forceTermination</a></strong>()</code>
<div class="block">Forces this barrier to enter termination state.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../jsr166y/Phaser.html#getArrivedParties()">getArrivedParties</a></strong>()</code>
<div class="block">Returns the number of registered parties that have arrived at
 the current phase of this barrier.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../jsr166y/Phaser.html" title="class in jsr166y">Phaser</a></code></td>
<td class="colLast"><code><strong><a href="../jsr166y/Phaser.html#getParent()">getParent</a></strong>()</code>
<div class="block">Returns the parent of this phaser, or <code>null</code> if none.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../jsr166y/Phaser.html#getPhase()">getPhase</a></strong>()</code>
<div class="block">Returns the current phase number.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../jsr166y/Phaser.html#getRegisteredParties()">getRegisteredParties</a></strong>()</code>
<div class="block">Returns the number of parties registered at this barrier.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../jsr166y/Phaser.html" title="class in jsr166y">Phaser</a></code></td>
<td class="colLast"><code><strong><a href="../jsr166y/Phaser.html#getRoot()">getRoot</a></strong>()</code>
<div class="block">Returns the root ancestor of this phaser, which is the same as
 this phaser if it has no parent.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../jsr166y/Phaser.html#getUnarrivedParties()">getUnarrivedParties</a></strong>()</code>
<div class="block">Returns the number of registered parties that have not yet
 arrived at the current phase of this barrier.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../jsr166y/Phaser.html#isTerminated()">isTerminated</a></strong>()</code>
<div class="block">Returns <code>true</code> if this barrier has been terminated.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected boolean</code></td>
<td class="colLast"><code><strong><a href="../jsr166y/Phaser.html#onAdvance(int, int)">onAdvance</a></strong>(int&nbsp;phase,
         int&nbsp;registeredParties)</code>
<div class="block">Overridable method to perform an action upon impending phase
 advance, and to control termination.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../jsr166y/Phaser.html#register()">register</a></strong>()</code>
<div class="block">Adds a new unarrived party to this phaser.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../jsr166y/Phaser.html#toString()">toString</a></strong>()</code>
<div class="block">Returns a string identifying this phaser, as well as its
 state.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="Phaser()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Phaser</h4>
<pre>public&nbsp;Phaser()</pre>
<div class="block">Creates a new phaser without any initially registered parties,
 initial phase number 0, and no parent. Any thread using this
 phaser will need to first register for it.</div>
</li>
</ul>
<a name="Phaser(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Phaser</h4>
<pre>public&nbsp;Phaser(int&nbsp;parties)</pre>
<div class="block">Creates a new phaser with the given number of registered
 unarrived parties, initial phase number 0, and no parent.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>parties</code> - the number of parties required to trip barrier</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if parties less than zero
 or greater than the maximum number of parties supported</dd></dl>
</li>
</ul>
<a name="Phaser(jsr166y.Phaser)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Phaser</h4>
<pre>public&nbsp;Phaser(<a href="../jsr166y/Phaser.html" title="class in jsr166y">Phaser</a>&nbsp;parent)</pre>
<div class="block">Creates a new phaser with the given parent, without any
 initially registered parties. If parent is non-null this phaser
 is registered with the parent and its initial phase number is
 the same as that of parent phaser.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>parent</code> - the parent phaser</dd></dl>
</li>
</ul>
<a name="Phaser(jsr166y.Phaser, int)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Phaser</h4>
<pre>public&nbsp;Phaser(<a href="../jsr166y/Phaser.html" title="class in jsr166y">Phaser</a>&nbsp;parent,
      int&nbsp;parties)</pre>
<div class="block">Creates a new phaser with the given parent and number of
 registered unarrived parties. If parent is non-null, this phaser
 is registered with the parent and its initial phase number is
 the same as that of parent phaser.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>parent</code> - the parent phaser</dd><dd><code>parties</code> - the number of parties required to trip barrier</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if parties less than zero
 or greater than the maximum number of parties supported</dd></dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="register()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>register</h4>
<pre>public&nbsp;int&nbsp;register()</pre>
<div class="block">Adds a new unarrived party to this phaser.
 If an ongoing invocation of <a href="../jsr166y/Phaser.html#onAdvance(int, int)"><code>onAdvance(int, int)</code></a> is in progress,
 this method may wait until its completion before registering.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>the arrival phase number to which this registration applied</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.IllegalStateException</code> - if attempting to register more
 than the maximum supported number of parties</dd></dl>
</li>
</ul>
<a name="bulkRegister(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bulkRegister</h4>
<pre>public&nbsp;int&nbsp;bulkRegister(int&nbsp;parties)</pre>
<div class="block">Adds the given number of new unarrived parties to this phaser.
 If an ongoing invocation of <a href="../jsr166y/Phaser.html#onAdvance(int, int)"><code>onAdvance(int, int)</code></a> is in progress,
 this method may wait until its completion before registering.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>parties</code> - the number of additional parties required to trip barrier</dd>
<dt><span class="strong">Returns:</span></dt><dd>the arrival phase number to which this registration applied</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.IllegalStateException</code> - if attempting to register more
 than the maximum supported number of parties</dd>
<dd><code>java.lang.IllegalArgumentException</code> - if <code>parties &lt; 0</code></dd></dl>
</li>
</ul>
<a name="arrive()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>arrive</h4>
<pre>public&nbsp;int&nbsp;arrive()</pre>
<div class="block">Arrives at the barrier, but does not wait for others.  (You can
 in turn wait for others via <a href="../jsr166y/Phaser.html#awaitAdvance(int)"><code>awaitAdvance(int)</code></a>).  It is an
 unenforced usage error for an unregistered party to invoke this
 method.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>the arrival phase number, or a negative value if terminated</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.IllegalStateException</code> - if not terminated and the number
 of unarrived parties would become negative</dd></dl>
</li>
</ul>
<a name="arriveAndDeregister()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>arriveAndDeregister</h4>
<pre>public&nbsp;int&nbsp;arriveAndDeregister()</pre>
<div class="block">Arrives at the barrier and deregisters from it without waiting
 for others. Deregistration reduces the number of parties
 required to trip the barrier in future phases.  If this phaser
 has a parent, and deregistration causes this phaser to have
 zero parties, this phaser also arrives at and is deregistered
 from its parent.  It is an unenforced usage error for an
 unregistered party to invoke this method.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>the arrival phase number, or a negative value if terminated</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.IllegalStateException</code> - if not terminated and the number
 of registered or unarrived parties would become negative</dd></dl>
</li>
</ul>
<a name="arriveAndAwaitAdvance()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>arriveAndAwaitAdvance</h4>
<pre>public&nbsp;int&nbsp;arriveAndAwaitAdvance()</pre>
<div class="block">Arrives at the barrier and awaits others. Equivalent in effect
 to <code>awaitAdvance(arrive())</code>.  If you need to await with
 interruption or timeout, you can arrange this with an analogous
 construction using one of the other forms of the <code>awaitAdvance</code> method.  If instead you need to deregister upon
 arrival, use <a href="../jsr166y/Phaser.html#arriveAndDeregister()"><code>arriveAndDeregister()</code></a>. It is an unenforced
 usage error for an unregistered party to invoke this method.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>the arrival phase number, or a negative number if terminated</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.IllegalStateException</code> - if not terminated and the number
 of unarrived parties would become negative</dd></dl>
</li>
</ul>
<a name="awaitAdvance(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>awaitAdvance</h4>
<pre>public&nbsp;int&nbsp;awaitAdvance(int&nbsp;phase)</pre>
<div class="block">Awaits the phase of the barrier to advance from the given phase
 value, returning immediately if the current phase of the
 barrier is not equal to the given phase value or this barrier
 is terminated.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>phase</code> - an arrival phase number, or negative value if
 terminated; this argument is normally the value returned by a
 previous call to <code>arrive</code> or its variants</dd>
<dt><span class="strong">Returns:</span></dt><dd>the next arrival phase number, or a negative value
 if terminated or argument is negative</dd></dl>
</li>
</ul>
<a name="awaitAdvanceInterruptibly(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>awaitAdvanceInterruptibly</h4>
<pre>public&nbsp;int&nbsp;awaitAdvanceInterruptibly(int&nbsp;phase)
                              throws java.lang.InterruptedException</pre>
<div class="block">Awaits the phase of the barrier to advance from the given phase
 value, throwing <code>InterruptedException</code> if interrupted
 while waiting, or returning immediately if the current phase of
 the barrier is not equal to the given phase value or this
 barrier is terminated.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>phase</code> - an arrival phase number, or negative value if
 terminated; this argument is normally the value returned by a
 previous call to <code>arrive</code> or its variants</dd>
<dt><span class="strong">Returns:</span></dt><dd>the next arrival phase number, or a negative value
 if terminated or argument is negative</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code> - if thread interrupted while waiting</dd></dl>
</li>
</ul>
<a name="awaitAdvanceInterruptibly(int, long, java.util.concurrent.TimeUnit)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>awaitAdvanceInterruptibly</h4>
<pre>public&nbsp;int&nbsp;awaitAdvanceInterruptibly(int&nbsp;phase,
                            long&nbsp;timeout,
                            java.util.concurrent.TimeUnit&nbsp;unit)
                              throws java.lang.InterruptedException,
                                     java.util.concurrent.TimeoutException</pre>
<div class="block">Awaits the phase of the barrier to advance from the given phase
 value or the given timeout to elapse, throwing <code>InterruptedException</code> if interrupted while waiting, or
 returning immediately if the current phase of the barrier is
 not equal to the given phase value or this barrier is
 terminated.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>phase</code> - an arrival phase number, or negative value if
 terminated; this argument is normally the value returned by a
 previous call to <code>arrive</code> or its variants</dd><dd><code>timeout</code> - how long to wait before giving up, in units of
        <code>unit</code></dd><dd><code>unit</code> - a <code>TimeUnit</code> determining how to interpret the
        <code>timeout</code> parameter</dd>
<dt><span class="strong">Returns:</span></dt><dd>the next arrival phase number, or a negative value
 if terminated or argument is negative</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code> - if thread interrupted while waiting</dd>
<dd><code>java.util.concurrent.TimeoutException</code> - if timed out while waiting</dd></dl>
</li>
</ul>
<a name="forceTermination()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>forceTermination</h4>
<pre>public&nbsp;void&nbsp;forceTermination()</pre>
<div class="block">Forces this barrier to enter termination state.  Counts of
 arrived and registered parties are unaffected.  If this phaser
 is a member of a tiered set of phasers, then all of the phasers
 in the set are terminated.  If this phaser is already
 terminated, this method has no effect.  This method may be
 useful for coordinating recovery after one or more tasks
 encounter unexpected exceptions.</div>
</li>
</ul>
<a name="getPhase()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPhase</h4>
<pre>public final&nbsp;int&nbsp;getPhase()</pre>
<div class="block">Returns the current phase number. The maximum phase number is
 <code>Integer.MAX_VALUE</code>, after which it restarts at
 zero. Upon termination, the phase number is negative.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>the phase number, or a negative value if terminated</dd></dl>
</li>
</ul>
<a name="getRegisteredParties()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRegisteredParties</h4>
<pre>public&nbsp;int&nbsp;getRegisteredParties()</pre>
<div class="block">Returns the number of parties registered at this barrier.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>the number of parties</dd></dl>
</li>
</ul>
<a name="getArrivedParties()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getArrivedParties</h4>
<pre>public&nbsp;int&nbsp;getArrivedParties()</pre>
<div class="block">Returns the number of registered parties that have arrived at
 the current phase of this barrier.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>the number of arrived parties</dd></dl>
</li>
</ul>
<a name="getUnarrivedParties()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUnarrivedParties</h4>
<pre>public&nbsp;int&nbsp;getUnarrivedParties()</pre>
<div class="block">Returns the number of registered parties that have not yet
 arrived at the current phase of this barrier.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>the number of unarrived parties</dd></dl>
</li>
</ul>
<a name="getParent()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getParent</h4>
<pre>public&nbsp;<a href="../jsr166y/Phaser.html" title="class in jsr166y">Phaser</a>&nbsp;getParent()</pre>
<div class="block">Returns the parent of this phaser, or <code>null</code> if none.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>the parent of this phaser, or <code>null</code> if none</dd></dl>
</li>
</ul>
<a name="getRoot()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRoot</h4>
<pre>public&nbsp;<a href="../jsr166y/Phaser.html" title="class in jsr166y">Phaser</a>&nbsp;getRoot()</pre>
<div class="block">Returns the root ancestor of this phaser, which is the same as
 this phaser if it has no parent.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>the root ancestor of this phaser</dd></dl>
</li>
</ul>
<a name="isTerminated()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isTerminated</h4>
<pre>public&nbsp;boolean&nbsp;isTerminated()</pre>
<div class="block">Returns <code>true</code> if this barrier has been terminated.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd><code>true</code> if this barrier has been terminated</dd></dl>
</li>
</ul>
<a name="onAdvance(int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onAdvance</h4>
<pre>protected&nbsp;boolean&nbsp;onAdvance(int&nbsp;phase,
                int&nbsp;registeredParties)</pre>
<div class="block">Overridable method to perform an action upon impending phase
 advance, and to control termination. This method is invoked
 upon arrival of the party tripping the barrier (when all other
 waiting parties are dormant).  If this method returns <code>true</code>, then, rather than advance the phase number, this barrier
 will be set to a final termination state, and subsequent calls
 to <a href="../jsr166y/Phaser.html#isTerminated()"><code>isTerminated()</code></a> will return true. Any (unchecked)
 Exception or Error thrown by an invocation of this method is
 propagated to the party attempting to trip the barrier, in
 which case no advance occurs.

 <p>The arguments to this method provide the state of the phaser
 prevailing for the current transition.  The effects of invoking
 arrival, registration, and waiting methods on this Phaser from
 within <code>onAdvance</code> are unspecified and should not be
 relied on.

 <p>If this Phaser is a member of a tiered set of Phasers, then
 <code>onAdvance</code> is invoked only for its root Phaser on each
 advance.

 <p>The default version returns <code>true</code> when the number of
 registered parties is zero. Normally, overrides that arrange
 termination for other reasons should also preserve this
 property.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>phase</code> - the phase number on entering the barrier</dd><dd><code>registeredParties</code> - the current number of registered parties</dd>
<dt><span class="strong">Returns:</span></dt><dd><code>true</code> if this barrier should terminate</dd></dl>
</li>
</ul>
<a name="toString()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>toString</h4>
<pre>public&nbsp;java.lang.String&nbsp;toString()</pre>
<div class="block">Returns a string identifying this phaser, as well as its
 state.  The state, in brackets, includes the String <code>"phase = "</code> followed by the phase number, <code>"parties = "</code>
 followed by the number of registered parties, and <code>"arrived = "</code> followed by the number of arrived parties.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code>toString</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
<dt><span class="strong">Returns:</span></dt><dd>a string identifying this barrier, as well as its state</dd></dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Phaser.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-all.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../jsr166y/LinkedTransferQueue.html" title="class in jsr166y"><span class="strong">Prev Class</span></a></li>
<li><a href="../jsr166y/RecursiveAction.html" title="class in jsr166y"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../index.html?jsr166y/Phaser.html" target="_top">Frames</a></li>
<li><a href="Phaser.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
