PixelsView 
  has array(s) of floats
    if one array, then index color
    otherwise, direct color

ColorMap
  has min and max range values
  has an index color model
  when min or max changes or when,
    fires ColorMapChanged event (received, say, by ColorBar)

FloatByteMap
  has clips (constructed with arrays)
  converts floats to bytes

FloatIndexColorMap


Methods for float-color mapping:
setClips(clipMin,clipMax)
getClipMin
getClipMax
setPercentiles
getPercentileMin/Max

setColorModel
getColorModel

setClips(int channel, double clipMin, double clipMax)
getClipMin(int channel) // exception if channel unused
getClipMax(int channel) // exception if channel unused
setPercentiles(...)

16-bit index?
ARGB = 1555?

linearly map azimuth to hue (byte)
linearly map dip to saturation (byte)
brightness = 1
Should interpolate bytes in hue space (impossible with OpenGL!)
then convert to RGB. But conversion too slow for every pixel.
So instead,
  linearly map to HSB bytes
  convert HSB bytes to RGB bytes




    public static int HSBtoRGB(float hue, float saturation, float brightness) {
	int r = 0, g = 0, b = 0;
    	if (saturation == 0) {
	    r = g = b = (int) (brightness * 255.0f + 0.5f);
	} else {
	    float h = (hue - (float)Math.floor(hue)) * 6.0f;
	    float f = h - (float)java.lang.Math.floor(h);
	    float p = brightness * (1.0f - saturation);
	    float q = brightness * (1.0f - saturation * f);
	    float t = brightness * (1.0f - (saturation * (1.0f - f)));
	    switch ((int) h) {
	    case 0:
		r = (int) (brightness * 255.0f + 0.5f);
		g = (int) (t * 255.0f + 0.5f);
		b = (int) (p * 255.0f + 0.5f);
		break;
	    case 1:
		r = (int) (q * 255.0f + 0.5f);
		g = (int) (brightness * 255.0f + 0.5f);
		b = (int) (p * 255.0f + 0.5f);
		break;
	    case 2:
		r = (int) (p * 255.0f + 0.5f);
		g = (int) (brightness * 255.0f + 0.5f);
		b = (int) (t * 255.0f + 0.5f);
		break;
	    case 3:
		r = (int) (p * 255.0f + 0.5f);
		g = (int) (q * 255.0f + 0.5f);
		b = (int) (brightness * 255.0f + 0.5f);
		break;
	    case 4:
		r = (int) (t * 255.0f + 0.5f);
		g = (int) (p * 255.0f + 0.5f);
		b = (int) (brightness * 255.0f + 0.5f);
		break;
	    case 5:
		r = (int) (brightness * 255.0f + 0.5f);
		g = (int) (p * 255.0f + 0.5f);
		b = (int) (q * 255.0f + 0.5f);
		break;
	    }
	}
	return 0xff000000 | (r << 16) | (g << 8) | (b << 0);
    }


