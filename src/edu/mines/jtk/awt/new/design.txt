ep el ei

     ei
    /  \
   /    \
  /      \
 /        \
ep---------el

-1 <= ep-el <= 1

0 for ep = el = 0.1, 0.2, ..., 0.5

ew = 0, ev = 1, eu = 2 => ep = el = 0.50
ew = 2, ev = 3, eu = 4 => ep = el = 0.25 

ep = (eu-ev)/eu
el = (ev-ew)/eu
ei = ew/eu


PixelsView 
  has array(s) of floats
    if one array, then index color
    otherwise, direct color

ColorMap
  has min and max range values
  has an index color model
  when min or max changes or when,
    fires ColorMapChanged event (received, say, by ColorBar)
  values are set by views when clips change

FloatByteMap
  has clips (constructed with arrays of floats)
  forwards setClips, setPercentiles, etc.
  converts floats to bytes

ColorMap
  has min and max range values
  has an index color model
  when min or max changes or when,
    fires ColorMapChanged event (received, say, by ColorBar)

FloatIndexColorMap extends ColorMap
  has IndexColorModel
  has FloatByteMap
    forwards setClips, setPercentiles, etc.
  getARGB(float)
  getABGR(float)

FloatDirectColorMap extends ColorMap
  has DirectColorModel
    supports either RGB or HSB
  has IndexColorModel 
    used for a specified color component
    for ColorMap implementation
  has FloatByteMap[3] ([4], if alpha)
    forwards setClips, setPercentiles, etc.
  getARGB(float,float,float)
  getARGB(float,float,float,float)
  getABGR(float,float,float)
  getAGBR(float,float,float,float)

FloatColorMap extends ColorMap
  has IndexColorModel 
    used for a specified color component
    for ColorMap implementation
  may have a DirectColorModel
  can convert HSB to RGB
  has FloatByteMap[1], [3] or [4]
    forwards setClips, setPercentiles, etc.
  getARGB(float) uses IndexColorMap
  getARGB(float,float,float) uses DirectColorMap
  getARGB(float,float,float,float) uses DirectColorMap
  getABGR(float)
  getABGR(float,float,float)
  getABGR(float,float,float,float)

Methods for float-color mapping:
setClips(clipMin,clipMax)
getClipMin
getClipMax
setPercentiles
getPercentileMin/Max

setClips(int component, double clipMin, double clipMax)
getClipMin(int component) // exception if component unused
getClipMax(int component) // exception if component unused
setPercentiles(...)

16-bit index?
ARGB = 1555?

linearly map azimuth to hue (byte)
linearly map dip to saturation (byte)
brightness = 1
Should interpolate bytes in hue space (impossible with OpenGL!)
then convert to RGB. But conversion too slow for every pixel.
So instead,
  linearly map to HSB bytes
  convert HSB bytes to RGB bytes

rgbrgb rrggbb
000000 000000  black
000001 000001  blue
000010 000100  green
000011 000101  cyan
000100 010000  red
000101 010001  magenta
000110 010100  yellow
000111 010101  gray
...
000000 000000  black
000001 000001  blue
000011 000101  cyan
000010 000100  green
000110 010100  yellow
000100 010000  red
000101 010001  magenta
000111 010101  gray
...

     


rrr ggg bbx
000 000 00x
000 001 00x
001 000 00x
001 001 00x
000 000 01x
000 010 00x
010 000 00x
000 001 01x
001 000 01x
001 001 01x



    public static int HSBtoRGB(float hue, float saturation, float brightness) {
	int r = 0, g = 0, b = 0;
    	if (saturation == 0) {
	    r = g = b = (int) (brightness * 255.0f + 0.5f);
	} else {
	    float h = (hue - (float)Math.floor(hue)) * 6.0f;
	    float f = h - (float)java.lang.Math.floor(h);
	    float p = brightness * (1.0f - saturation);
	    float q = brightness * (1.0f - saturation * f);
	    float t = brightness * (1.0f - (saturation * (1.0f - f)));
	    switch ((int) h) {
	    case 0:
		r = (int) (brightness * 255.0f + 0.5f);
		g = (int) (t * 255.0f + 0.5f);
		b = (int) (p * 255.0f + 0.5f);
		break;
	    case 1:
		r = (int) (q * 255.0f + 0.5f);
		g = (int) (brightness * 255.0f + 0.5f);
		b = (int) (p * 255.0f + 0.5f);
		break;
	    case 2:
		r = (int) (p * 255.0f + 0.5f);
		g = (int) (brightness * 255.0f + 0.5f);
		b = (int) (t * 255.0f + 0.5f);
		break;
	    case 3:
		r = (int) (p * 255.0f + 0.5f);
		g = (int) (q * 255.0f + 0.5f);
		b = (int) (brightness * 255.0f + 0.5f);
		break;
	    case 4:
		r = (int) (t * 255.0f + 0.5f);
		g = (int) (p * 255.0f + 0.5f);
		b = (int) (brightness * 255.0f + 0.5f);
		break;
	    case 5:
		r = (int) (brightness * 255.0f + 0.5f);
		g = (int) (p * 255.0f + 0.5f);
		b = (int) (q * 255.0f + 0.5f);
		break;
	    }
	}
	return 0xff000000 | (r << 16) | (g << 8) | (b << 0);
    }


